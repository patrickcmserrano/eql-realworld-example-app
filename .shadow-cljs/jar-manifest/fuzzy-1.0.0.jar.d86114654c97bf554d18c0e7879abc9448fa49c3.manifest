["^ ","~:foreign-libs",[],"~:externs",[],"~:resources",[["^ ","~:cache-key",["d86114654c97bf554d18c0e7879abc9448fa49c3"],"~:output-name","com.wsscode.fuzzyjs.js","~:resource-id",["~:shadow.build.classpath/resource","com/wsscode/fuzzyjs.js"],"~:resource-name","com/wsscode/fuzzyjs.js","~:type","~:goog","~:source","// LICENSE\n//\n//   This software is dual-licensed to the public domain and under the following\n//   license: you are granted a perpetual, irrevocable license to copy, modify,\n//   publish, and distribute this file as you see fit.\n//\n// VERSION \n//   0.1.0  (2016-03-28)  Initial release\n//\n// AUTHOR\n//   Forrest Smith\n//\n// CONTRIBUTORS\n//   Jørgen Tjernø - async helper\n//   Wilker Lucio - modified to work as a google closure module\n\n\"use strict\";\n\ngoog.provide(\"com.wsscode.fuzzyjs\");\n\n// Returns true if each character in pattern is found sequentially within str\n/**\n * Simple fuzzy match\n * @param {string} pattern The pattern to lookup\n * @param {string} str The string to search into\n * @return {boolean} True if `pattern` matches `str`.\n */\ncom.wsscode.fuzzyjs.fuzzy_match_simple = function(pattern, str) {\n    var patternIdx = 0;\n    var strIdx = 0;\n    var patternLength = pattern.length;\n    var strLength = str.length;\n\n    while (patternIdx !== patternLength && strIdx !== strLength) {\n        var patternChar = pattern.charAt(patternIdx).toLowerCase();\n        var strChar = str.charAt(strIdx).toLowerCase();\n        if (patternChar === strChar)\n            ++patternIdx;\n        ++strIdx;\n    }\n\n    return patternLength !== 0 && strLength !== 0 && patternIdx === patternLength;\n};\n\n// Returns [bool, score, formattedStr]\n// bool: true if each character in pattern is found sequentially within str\n// score: integer; higher is better match. Value has no intrinsic meaning. Range varies with pattern. \n//        Can only compare scores with same search pattern.\n// formattedStr: input str with matched characters marked in <b> tags. Delete if unwanted.\n/**\n * Simple fuzzy match\n * @param {string} pattern The pattern to lookup\n * @param {string} str The string to search into\n */\ncom.wsscode.fuzzyjs.fuzzy_match = function(pattern, str) {\n    // Score consts\n    var adjacency_bonus = 5;                // bonus for adjacent matches\n    var separator_bonus = 10;               // bonus if match occurs after a separator\n    var camel_bonus = 10;                   // bonus if match is uppercase and prev is lower\n    var leading_letter_penalty = -3;        // penalty applied for every letter in str before the first match\n    var max_leading_letter_penalty = -9;    // maximum penalty for leading letters\n    var unmatched_letter_penalty = -1;      // penalty for every letter that doesn't matter\n\n    // Loop variables\n    var score = 0;\n    var patternIdx = 0;\n    var patternLength = pattern.length;\n    var strIdx = 0;\n    var strLength = str.length;\n    var prevMatched = false;\n    var prevLower = false;\n    var prevSeparator = true;       // true so if first letter match gets separator bonus\n\n    // Use \"best\" matched letter if multiple string letters match the pattern\n    var bestLetter = null;\n    var bestLower = null;\n    var bestLetterIdx = null;\n    var bestLetterScore = 0;\n\n    var matchedIndices = [];\n\n    // Loop over strings\n    while (strIdx !== strLength) {\n        var patternChar = patternIdx !== patternLength ? pattern.charAt(patternIdx) : null;\n        var strChar = str.charAt(strIdx);\n\n        var patternLower = patternChar != null ? patternChar.toLowerCase() : null;\n        var strLower = strChar.toLowerCase();\n        var strUpper = strChar.toUpperCase();\n\n        var nextMatch = patternChar && patternLower === strLower;\n        var rematch = bestLetter && bestLower === strLower;\n\n        var advanced = nextMatch && bestLetter;\n        var patternRepeat = bestLetter && patternChar && bestLower === patternLower;\n        if (advanced || patternRepeat) {\n            score += bestLetterScore;\n            matchedIndices.push(bestLetterIdx);\n            bestLetter = null;\n            bestLower = null;\n            bestLetterIdx = null;\n            bestLetterScore = 0;\n        }\n\n        if (nextMatch || rematch) {\n            var newScore = 0;\n\n            // Apply penalty for each letter before the first pattern match\n            // Note: std::max because penalties are negative values. So max is smallest penalty.\n            if (patternIdx === 0) {\n              score += Math.max(strIdx * leading_letter_penalty, max_leading_letter_penalty);\n            }\n\n            // Apply bonus for consecutive bonuses\n            if (prevMatched)\n                newScore += adjacency_bonus;\n\n            // Apply bonus for matches after a separator\n            if (prevSeparator)\n                newScore += separator_bonus;\n\n            // Apply bonus across camel case boundaries. Includes \"clever\" isLetter check.\n            if (prevLower && strChar === strUpper && strLower !== strUpper)\n                newScore += camel_bonus;\n\n            // Update patter index IFF the next pattern letter was matched\n            if (nextMatch)\n                ++patternIdx;\n\n            // Update best letter in str which may be for a \"next\" letter or a \"rematch\"\n            if (newScore >= bestLetterScore) {\n\n                // Apply penalty for now skipped letter\n                if (bestLetter != null)\n                    score += unmatched_letter_penalty;\n\n                bestLetter = strChar;\n                bestLower = bestLetter.toLowerCase();\n                bestLetterIdx = strIdx;\n                bestLetterScore = newScore;\n            }\n\n            prevMatched = true;\n        }\n        else {\n            // Append unmatch characters\n            formattedStr += strChar;\n\n            score += unmatched_letter_penalty;\n            prevMatched = false;\n        }\n\n        // Includes \"clever\" isLetter check.\n        prevLower = strChar === strLower && strLower !== strUpper;\n        prevSeparator = strChar === '_' || strChar === ' ';\n\n        ++strIdx;\n    }\n\n    // Apply score for last match\n    if (bestLetter) {\n        score += bestLetterScore;\n        matchedIndices.push(bestLetterIdx);\n    }\n\n    // Finish out formatted string after last pattern matched\n    // Build formated string based on matched letters\n    var formattedStr = \"\";\n    var lastIdx = 0;\n    for (var i = 0; i < matchedIndices.length; ++i) {\n        var idx = matchedIndices[i];\n        formattedStr += str.substr(lastIdx, idx - lastIdx) + \"<b>\" + str.charAt(idx) + \"</b>\";\n        lastIdx = idx + 1;\n    }\n    formattedStr += str.substr(lastIdx, str.length - lastIdx);\n\n    var matched = patternIdx === patternLength;\n    return [matched, score, formattedStr];\n};\n\n// Strictly optional utility to help make using fts_fuzzy_match easier for large data sets\n// Uses setTimeout to process matches before a maximum amount of time before sleeping\n//\n// To use:\n//      var asyncMatcher = new fts_fuzzy_match(fuzzy_match, \"fts\", \"ForrestTheWoods\", \n//                                              function(results) { console.log(results); });\n//      asyncMatcher.start();\n//\ncom.wsscode.fuzzyjs.fts_fuzzy_match_async = function(matchFn, pattern, dataSet, onComplete) {\n    var ITEMS_PER_CHECK = 1000;         // performance.now can be very slow depending on platform\n\n    var max_ms_per_frame = 1000.0/30.0; // 30FPS\n    var dataIndex = 0;\n    var results = [];\n    var resumeTimeout = null;\n\n    // Perform matches for at most max_ms\n    function step() {\n        clearTimeout(resumeTimeout);\n        resumeTimeout = null;\n\n        var stopTime = performance.now() + max_ms_per_frame;\n\n        for (; dataIndex < dataSet.length; ++dataIndex) {\n            if ((dataIndex % ITEMS_PER_CHECK) === 0) {\n                if (performance.now() > stopTime) {\n                    resumeTimeout = setTimeout(step, 1);\n                    return;\n                }\n            }\n\n            var str = dataSet[dataIndex];\n            var result = matchFn(pattern, str);\n            \n            // A little gross because fuzzy_match_simple and fuzzy_match return different things\n            if (matchFn === com.wsscode.fuzzyjs.fuzzy_match_simple && result === true)\n                results.push(str);\n            else if (matchFn === com.wsscode.fuzzyjs.fuzzy_match && result[0] === true)\n                results.push(result);\n        }\n\n        onComplete(results);\n        return null;\n    }\n\n    // Abort current process\n    var cancel = function() {\n        if (resumeTimeout !== null)\n            clearTimeout(resumeTimeout);\n    };\n\n    // Must be called to start matching.\n    // I tried to make asyncMatcher auto-start via \"var resumeTimeout = step();\" \n    // However setTimout behaving in an unexpected fashion as onComplete insisted on triggering twice.\n    var start = function() {\n        step();\n    };\n\n    // Process full list. Blocks script execution until complete\n    var flush = function() {\n        max_ms_per_frame = Infinity;\n        step();\n    };\n\n    return {cancel: cancel, start: start, flush: flush};\n};\n","~:last-modified",1581097635000,"~:requires",["~#set",["~$goog"]],"~:pom-info",["^ ","~:group-id","~$com.wsscode","~:artifact-id","~$fuzzy","~:version","1.0.0","~:name","fuzzy","~:description","Fuzzy search algorithm for Clojurescript","~:url","https://github.com/wilkerlucio/fuzzy-cljs","~:id","~$com.wsscode/fuzzy","~:coordinate",["^I","1.0.0"]],"~:inspect-info",["^ ","~:js-str-offsets",[],"~:js-esm",false,"~:js-imports",[],"~:js-invalid-requires",[],"~:goog-provides",["com.wsscode.fuzzyjs"],"~:js-language","es3","~:goog-module",null,"~:js-requires",[],"~:goog-requires",[],"~:uses-global-buffer",false,"~:uses-global-process",false],"^G",["~#url","jar:file:/home/patro/.m2/repository/com/wsscode/fuzzy/1.0.0/fuzzy-1.0.0.jar!/com/wsscode/fuzzyjs.js"],"~:provides",["^=",["~$com.wsscode.fuzzyjs"]],"~:from-jar",true,"~:deps",["^>"]]],"~:data-readers",null,"~:shadow.build.classpath/CACHE-TIMESTAMP",1598567487000]